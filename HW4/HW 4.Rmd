---
title: "HW4"
author: 'BBC: Bichay, Bovee, Coeman'
date: "2/16/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Homework 4

# Slide 47

```{r}

```

# Slide 50



```{r}

```


## Functions chapter Problems
# Function Components
1.What function allows you to tell if an object is a function?
What function allows you to tell if a function is a primitive function?

2.  This code makes a list of all functions in the base package.

objs <- mget(ls("package:base"), inherits = TRUE)
funs <- Filter(is.function, objs)
Use it to answer the following questions:

2a. Which base function has the most arguments?

2b. How many base functions have no arguments? What’s special about those functions?

2c. How could you adapt the code to find all primitive functions?

3. What are the three important components of a function?

4. When does printing a function not show what environment it was created in?

# Lexical Scoping

1. What does the following code return? Why? What does each of the three c’s mean?

c <- 10
c(c = c)

2. What are the four principles that govern how R looks for values?

3. What does the following function return? Make a prediction before running the code yourself.

f <- function(x) {
  f <- function(x) {
    f <- function(x) {
      x ^ 2
    }
    f(x) + 1
  }
  f(x) * 2
}
f(10)

# Function Arguments
1. Clarify the following list of odd function calls:

x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)

2. What does this function return? Why? Which principle does it illustrate?

f1 <- function(x = {y <- 1; 2}, y = 0) {
  x + y
}
f1()

3. What does this function return? Why? Which principle does it illustrate?

f2 <- function(x = z) {
  z <- 100
  x
}
f2()

# Special calls

1. Create a list of all the replacement functions found in the base package. Which ones are primitive functions?

2. What are valid names for user-created infix functions?

3. Create an infix xor() operator.

4. Create infix versions of the set functions intersect(), union(), and setdiff().

5. Create a replacement function that modifies a random location in a vector.

#Return Values

1. How does the chdir parameter of source() compare to in_dir()? Why might you prefer one approach to the other?

2. What function undoes the action of library()? How do you save and restore the values of options() and par()?

3. Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code worked).

4. We can use on.exit() to implement a simple version of capture.output().

capture.output2 <- function(code) {
  temp <- tempfile()
  on.exit(file.remove(temp), add = TRUE)

  sink(temp)
  on.exit(sink(), add = TRUE)

  force(code)
  readLines(temp)
}
capture.output2(cat("a", "b", "c", sep = "\n"))
# [1] "a" "b" "c"
Compare capture.output() to capture.output2(). How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas to be easier to understand?

## Functional Programming chapter Problems

# Anonymous Functions

1. Given a function, like "mean", match.fun() lets you find a function. Given a function, can you find its name? Why doesn’t that make sense in R?

2. Use lapply() and an anonymous function to find the coefficient of variation (the standard deviation divided by the mean) for all columns in the mtcars dataset.

3. Use integrate() and an anonymous function to find the area under the curve for the following functions. Use Wolfram Alpha to check your answers.

y = x ^ 2 - x, x in [0, 10]
y = sin(x) + cos(x), x in [-π, π]
y = exp(x) / x, x in [10, 20]

4. A good rule of thumb is that an anonymous function should fit on one line and shouldn’t need to use {}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?



# Closures

1. Why are functions created by other functions called closures?

2. What does the following statistical function do? What would be a better name for it? (The existing name is a bit of a hint.)

bc <- function(lambda) {
  if (lambda == 0) {
    function(x) log(x)
  } else {
    function(x) (x ^ lambda - 1) / lambda
  }
}

3. What does approxfun() do? What does it return?

4. What does ecdf() do? What does it return?

5. Create a function that creates functions that compute the ith central moment of a numeric vector. You can test it by running the following code:

m1 <- moment(1)
m2 <- moment(2)

x <- runif(100)
stopifnot(all.equal(m1(x), 0))
stopifnot(all.equal(m2(x), var(x) * 99 / 100))

6. Create a function pick() that takes an index, i, as an argument and returns a function with an argument x that subsets x with i.

lapply(mtcars, pick(5))
# should do the same as this
lapply(mtcars, function(x) x[[5]])

# Lists of Functions

1. Implement a summary function that works like base::summary(), but uses a list of functions. Modify the function so it returns a closure, making it possible to use it as a function factory.

2. Which of the following commands is equivalent to with(x, f(z))?

x$f(x$z).
f(x$z).
x$f(z).
f(z).
It depends.

# Case Study: Numerical Integration

1. Instead of creating individual functions (e.g., midpoint(), trapezoid(), simpson(), etc.), we could store them in a list. If we did that, how would that change the code? Can you create the list of functions from a list of coefficients for the Newton-Cotes formulae?

2. The trade-off between integration rules is that more complex rules are slower to compute, but need fewer pieces. For sin() in the range [0, π], determine the number of pieces needed so that each rule will be equally accurate. Illustrate your results with a graph. How do they change for different functions? sin(1 / x^2) is particularly challenging.



